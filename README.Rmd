---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
```

*Note: this branch is dedicated to development of __fitting a 1 state model__ within the `mHMM()` function. This development is near complete. When the development is complete (e.g., documentation is complete, functions thoroughly tested), the developments will be incorporated in the master branch, and eventually in the stable R CRAN version of the mHMM package.*

# mHMMbayes

  With the \code{R} package mHMMbayes you can fit multilevel hidden Markov
  models. The multilevel hidden Markov model (HMM) is a generalization of the
  well-known hidden Markov model, tailored to accommodate (intense) longitudinal
  data of multiple individuals simultaneously. Using a multilevel framework, we
  allow for heterogeneity in the model parameters (transition probability matrix
  and conditional distribution), while estimating one overall HMM. The model has
  a great potential of application in  many fields, such as the social sciences
  and medicine. The model can be fitted on multivariate data with categorical,
  continuous (i.e., normally distributed), or count (i.e., Poisson distributed)
  observations, and include individual level covariates (allowing for e.g.,
  group comparisons on model parameters). Parameters are estimated using
  Bayesian estimation utilizing the forward-backward recursion within a hybrid
  Metropolis within Gibbs sampler. Missing data (NA) in the dependent variables
  is accommodated assuming MAR. The package also includes various options for
  model visualization, a function to simulate data and a function to obtain the
  most likely hidden state sequence for each individual using the Viterbi
  algorithm.
  
  Please do not hesitate to contact me if you have any questions regarding the 
  package. 

## Installation

You can install mHMMbayes that incorporates the possibility of fitting a 1-state model from github with:

```{r gh-installation, eval = FALSE}
# install.packages("devtools")
devtools::install_github("emmekeaarts/mHMMbayes@one-state")
```

## Usage
This is a basic example which shows you how to run the model using simulated
continuous data with one state. For a general, more
elaborate introduction, see the vignette “tutorial-mhmm” accompanying
the package.


```{r example3}
library(mHMMbayes)

###### Example on simulated data
# simulating multivariate continuous data
n_t     <- 100
n       <- 10
m       <- 1
n_dep   <- 2

gamma   <- matrix(c(1), ncol = m, byrow = TRUE)

emiss_distr <- list(matrix(c( 50, 10), nrow = m, byrow = TRUE),
                    matrix(c(5, 2), nrow = m, byrow = TRUE))

set.seed(2327)
data_cont <- sim_mHMM(n_t = n_t, n = n, data_distr = 'continuous', gen = list(m = m, n_dep = n_dep),
                  gamma = gamma, emiss_distr = emiss_distr, var_gamma = .1, var_emiss = c(5^2, 0.2^2))

# Specify hyper-prior for the continuous emission distribution
manual_prior_emiss <- prior_emiss_cont(gen = list(m = m, n_dep = n_dep),
                                       emiss_mu0 = list(matrix(c(30), nrow = 1),
                                                        matrix(c(7), nrow = 1)),
                                       emiss_K0 = list(1, 1),
                                       emiss_V =  list(rep(5^2, m), rep(0.5^2, m)),
                                       emiss_nu = list(1, 1),
                                       emiss_a0 = list(rep(1.5, m), rep(1, m)),
                                       emiss_b0 = list(rep(20, m), rep(4, m)))

# Run the model on the simulated data:
set.seed(9834)
out_1st_cont_sim <- mHMM(s_data = data_cont$obs,
                         data_distr = 'continuous',
                         gen = list(m = m, n_dep = n_dep),
                         start_val = c(list(gamma), emiss_distr),
                         emiss_hyp_prior = manual_prior_emiss,
                          mcmc = list(J = 1000, burn_in = 200))

out_1st_cont_sim
summary(out_1st_cont_sim)

# obtaining the emission distribution 
# at the group and subject level 
obtain_emiss(out_1st_cont_sim, level = 'group')
obtain_emiss(out_1st_cont_sim, level = 'subject')

# note that as the transition probability matrix always equals 1, 
# as such running the function obtain_gamma() function on output of a 1-state model will not run (and will throw an explanation)

# note that as all states over time equal 1, inferring the most likely state at each point in time is obsolete. 
# as such, running the vit_mHMM() function on output of a 1-state model will not run (and will throw an explanation)
```
