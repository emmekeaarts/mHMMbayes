#' Plotting the posterior densities for a fitted multilevel HMM
#'
#' \code{plot.mHMM} plots the posterior densities for a fitted multilevel hidden
#' Markov model for the group and subject level parameters simultaneously. The
#' plotted posterior densities are either for the transition probability matrix
#' gamma, or for the emission distribution probabilities. If the ggplot2 package
#' is available, it generates a ggplot; otherwise, it generates a base R plot.
#'
#' @param x Object of class \code{mHMM}, generated by the function
#'   \code{\link{mHMM}}.
#' @param component String specifying if the displayed posterior densities
#'   should be for the transition probability matrix gamma (\code{component =
#'   "gamma"}), or for the emission distribution probabilities (\code{component
#'   = "emiss"}). In case of the latter and the model is based on multiple
#'   dependent variables, the user has to indicate for which dependent variable
#'   the posterior densities have to be plotted, see \code{dep}.
#' @param dep Integer specifying for which dependent variable the posterior
#'   densities should be plotted. Only required if one wishes to plot the
#'   emission distribution probabilities and the model is based on multiple
#'   dependent variables.
#' @param col Vector of colors for the posterior density lines. If one is
#'   plotting the posterior densities for gamma, the vector has length \code{m}
#'   (i.e., number of hidden states). If one is plotting the posterior densities
#'   for the emission probabilities, the vector has length \code{q_emiss[k]}
#'   (i.e., the number of outcome categories for the dependent variable
#'   \code{k}). If not specified, colors will be assigned automatically.
#' @param cat_lab Optional vector of strings when plotting the posterior
#'   densities of the emission probabilities, denoting the labels of the
#'   categorical outcome values. Automatically generated when not provided.
#' @param dep_lab Optional string when plotting the posterior
#'   densities of the emission probabilities with length 1, denoting the label
#'   for the dependent variable plotted. Automatically obtained from the input
#'   object \code{x} when not specified.
#' @param lwd1 Positive number indicating the line width of the posterior
#'   density at the group level (when using base R plotting function).
#' @param lwd2 Positive number indicating the line width of the posterior
#'   density at the subject level (when using base R plotting function).
#' @param lty1 Positive number indicating the line type of the posterior
#'   density at the group level (when using base R plotting function).
#' @param lty2 Positive number indicating the line type of the posterior
#'   density at the subject level (when using base R plotting function).
#' @param burn_in An integer which specifies the number of iterations to discard
#'   when obtaining the model parameter summary statistics. When left
#'   unspecified, the burn in period specified at creating the \code{mHMM}
#'   object with the function \code{\link{mHMM}} will be used.
#' @param legend_cex A numerical value giving the amount by which plotting text
#'   and symbols in the legend should be magnified relative to the default
#'   (when using base R plotting function).
#' @param ... Arguments to be passed to methods (see \code{\link[graphics]{par}})
#'
#' @return \code{plot.mHMM} returns a plot of the posterior densities. Depending
#'   on whether (\code{component = "gamma"}) or (\code{component = "emiss"}),
#'   the plotted posterior densities are either for the transition probability
#'   matrix gamma or for the emission distribution probabilities, respectively.
#'
#' @seealso \code{\link{mHMM}} for fitting the multilevel hidden Markov
#'   model, creating the object \code{mHMM}.
#'
#' @examples
#' ###### Example on package example data, see ?nonverbal
#' # First run the function mHMM on example data
#' \donttest{
#' # specifying general model properties:
#' m <- 2
#' n_dep <- 4
#' q_emiss <- c(3, 2, 3, 2)
#'
#' # specifying starting values
#' start_TM <- diag(.8, m)
#' start_TM[lower.tri(start_TM) | upper.tri(start_TM)] <- .2
#' start_EM <- list(matrix(c(0.05, 0.90, 0.05, 0.90, 0.05, 0.05), byrow = TRUE,
#'                         nrow = m, ncol = q_emiss[1]), # vocalizing patient
#'                  matrix(c(0.1, 0.9, 0.1, 0.9), byrow = TRUE, nrow = m,
#'                         ncol = q_emiss[2]), # looking patient
#'                  matrix(c(0.90, 0.05, 0.05, 0.05, 0.90, 0.05), byrow = TRUE,
#'                         nrow = m, ncol = q_emiss[3]), # vocalizing therapist
#'                  matrix(c(0.1, 0.9, 0.1, 0.9), byrow = TRUE, nrow = m,
#'                         ncol = q_emiss[4])) # looking therapist
#'
#' # Run a model without covariate(s):
#' out_2st <- mHMM(s_data = nonverbal, gen = list(m = m, n_dep = n_dep,
#'                 q_emiss = q_emiss), start_val = c(list(start_TM), start_EM),
#'                 mcmc = list(J = 11, burn_in = 5))
#'
#' ## plot the posterior densities for gamma
#' plot(out_2st, component = "gamma")
#' }
#'
#' @export
#'

plot.mHMM <- function(x, component = "gamma", dep = 1, col, cat_lab,
                      dep_lab, lwd1 = 2, lwd2 = 1, lty1 = 1, lty2 = 3,
                      legend_cex, burn_in, ...){
  if (!is.mHMM(x)){
    stop("The input object x should be from the class mHMM, obtained with the function mHMM.")
  }
  if (component != "gamma" & component != "emiss"){
    stop("The input specified under component should be a string, restrectid to state either gamma or emiss.")
  }
  object <- x
  input   <- x$input
  n_subj  <- input$n_subj
  if (missing(burn_in)){
    burn_in <- input$burn_in
  }
  J <- input$J
  if (burn_in >= (J-1)){
    stop(paste("The specified burn in period should be at least 2 points smaller
               compared to the number of iterations J, J =", J))
  }
  m       <- input$m
  q_emiss <- input$q_emiss
  n_dep   <- input$n_dep

  # if plotting gamma
  if(component == "gamma"){
    # if ggplot2 is available
    if(nzchar(system.file(package = "ggplot2"))){
      if (missing(col)){
        state_col <- scales::hue_pal()(m) #RColorBrewer::brewer.pal(m, "Pastel1")
      } else {state_col <- col}
      # group level gamma
      gg <- object$gamma_prob_bar |>
        tibble::as_tibble() |>
        dplyr::slice(-(1:burn_in)) |>
        dplyr::mutate(id = "group")

      # extract the peak of density for group level gamma
      peak <- gg |>
        tidyr::pivot_longer(!id) |>
        dplyr::summarize(ymax = max(stats::density(value)$y), .by = name) |>
        dplyr::mutate(name = gsub("to.*", "", name)) |>
        dplyr::summarize(ymax = max(ymax), .by = name) |>
        dplyr::mutate(ymin = 0) |>
        dplyr::group_split(name) |>
        stats::setNames(paste("From state", 1:m)) |>
        purrr::map(~
                     ggplot2::scale_y_continuous(limits = c(.x$ymin, .x$ymax))
        )

      # subject level gamma
      sg <- object$PD_subj |>
        purrr::map(
          ~ tibble::as_tibble(.x) |>
            dplyr::select(tidyselect::starts_with("S")) |>
            dplyr::slice(-(1:burn_in))) |>
        dplyr::bind_rows(.id="id")

      # structure df for plotting
      df <- rbind(sg, gg) |>
        tidyr::pivot_longer(cols = !id, names_to = "class", values_to = "value") |>
        dplyr::mutate(from_state = stringr::str_split(class, "to", simplify = T)[,1],
                      to_state = stringr::str_split(class, "to", simplify = T)[,2],
                      lty = as.factor(ifelse(id == "group", 1, 2)),
                      dplyr::across(from_state:to_state, \(x) stringr::str_replace(x, "S", "state ")))

      # create plots
      plt <- df |>
        ggplot2::ggplot(ggplot2::aes(x = value, color = to_state,
                                     alpha = id, linetype = lty, linewidth = lty)) +
        ggplot2::geom_density() +
        ggplot2::xlim(0, 1) +
        ggplot2::scale_linewidth_manual(values = c("1" = 0.8, "2" = 0.2)) +
        ggplot2::scale_linetype_discrete(name = "Level", labels = c("group", "subject")) +
        ggplot2::scale_color_manual(values = state_col, name = "",
                                    labels = paste("To state", 1:m)) +
        ggplot2::facet_wrap(~from_state, labeller = ggplot2::as_labeller(
          function(string, prefix = "From") paste(prefix, string)), scales = "free_y") +
        ggh4x::facetted_pos_scales(y = peak) +
        ggplot2::guides(alpha = "none", linewidth = "none") +
        ggplot2::labs(title = "Posterior densities of transition probabilities",
                      y = "", x = "") +
        ggplot2::theme_bw() +
        ggplot2::theme(panel.spacing.x = ggplot2::unit(4, "mm"),
                       legend.position = "bottom",
                       axis.text.y = ggplot2::element_blank(),
                       axis.ticks.y = ggplot2::element_blank())
      print.ggplot(plt) |> suppressWarnings()

      # if ggplot2 is not available, original function follows
    } else {
      old_par <- graphics::par(no.readonly =TRUE)
      on.exit(graphics::par(old_par))
      if (missing(col)){
        state_col <- grDevices::rainbow(m)
      } else {
        state_col <- col
      }
      if(m > 3){
        graphics::par(mfrow = c(2,ceiling(m/2)), mar = c(4,2,3,1) + 0.1, mgp = c(2,1,0))
      } else {
        graphics::par(mfrow = c(1,m), mar = c(4,2,3,1) + 0.1, mgp = c(2,1,0))
      }
      for(i in 1:m){
        max <- 0
        for(j in 1:m){
          new <- max(stats::density(object$gamma_prob_bar[burn_in:J, m * (i-1) + j])$y)
          if(new > max){max <- new}
        }
        graphics::plot.default(x = 1, ylim = c(0, max), xlim = c(0,1), type = "n",
                               cex = .8,  main = paste("From state", i, "to state ..."),
                               yaxt = "n", ylab = "",
                               xlab = "Transition probability", ...)
        graphics::title(ylab="Density", line=.5)
        for(j in 1:m){
          graphics::lines(stats::density(object$gamma_prob_bar[burn_in:J,m * (i-1) + j]),
                          type = "l", col = state_col[j], lwd = lwd1, lty = lty1)
          for(s in 1:n_subj){
            graphics::lines(stats::density(object$PD_subj[[s]]
                                           [burn_in:J,(sum(q_emiss * m) + m * (i-1) + j)]),
                            type = "l", col = state_col[j], lwd = lwd2, lty = lty2)
          }
        }
        graphics::legend("topright", col = state_col, legend = paste("To state", 1:m),
                         bty = 'n', lty = 1, lwd = 2, cex = .8)
      }
    }

    # if plotting emiss
  } else if (component == "emiss"){
    if (missing(col)){
      cat_col <- scales::hue_pal()(q_emiss[dep]) #RColorBrewer::brewer.pal(q_emiss[dep], "Pastel1")
    } else {cat_col <- col}
    if (missing(cat_lab)){
      cat_lab <- paste("Category", 1:q_emiss[dep])
    }
    if (missing(dep_lab)){
      dep_lab <- input$dep_labels[dep]
    }
    # if ggplot2 is available
    if(nzchar(system.file(package = "ggplot2"))){
      # group level emission
      ge <- object$emiss_prob_bar[[dep]] |>
        tibble::as_tibble() |>
        dplyr::slice(-(1:burn_in)) |>
        dplyr::mutate(id = "group") |>
        dplyr::relocate(id)

      # extract the peak per state
      peak <- ge |>
        tidyr::pivot_longer(!id) |>
        dplyr::summarize(ymax = max(stats::density(value)$y), .by = name) |>
        dplyr::mutate(name = gsub(".*_", "", name)) |>
        dplyr::summarize(ymax = max(ymax), .by = name) |>
        dplyr::mutate(ymin = 0) |>
        dplyr::group_split(name) |>
        stats::setNames(paste("State", 1:m)) |>
        purrr::map(~
                     ggplot2::scale_y_continuous(limits = c(.x$ymin, .x$ymax))
        )

      # subject level emission
      se <- object$PD_subj|>purrr::map(
        ~ tibble::as_tibble(.x) |>
          dplyr::slice(-(1:burn_in)) |>
          dplyr::select(tidyselect::contains(paste0("q", dep, collapse="")))) |>
        dplyr::bind_rows(.id="id") |>
        magrittr::set_colnames(colnames(ge))

      # structure df for plotting
      df <- rbind(se, ge) |>
        tidyr::pivot_longer(cols = !id, names_to = "class", values_to = "value") |>
        dplyr::mutate(category = stringr::str_split(class, "_", simplify = T)[,1],
                      state = stringr::str_split(class, "_", simplify = T)[,2],
                      lty = as.factor(ifelse(id == "group", 1, 2)),
                      dplyr::across(state, \(x) stringr::str_replace(x, "S", "State ")))
      # create plots
      plt <- df |>
        ggplot2::ggplot(ggplot2::aes(x = value, color = category,
                                     alpha = id, linetype = lty, linewidth = lty)) +
        ggplot2::geom_density() +
        ggplot2::xlim(0, 1) +
        ggplot2::scale_linewidth_manual(values = c("1" = 0.8, "2" = 0.2))+
        ggplot2::scale_linetype_discrete(name = "Level", labels = c("group", "subject"))+
        ggplot2::scale_color_manual(values = cat_col, name = "", labels = cat_lab) +
        ggplot2::facet_wrap(~state, scales = "free_y") +
        ggh4x::facetted_pos_scales(y = peak) +
        ggplot2::guides(alpha = "none", linewidth = "none") +
        ggplot2::labs(title = paste("Posterior densities of emission probabilities for",
                                    dep_lab), x = "", y = "") +
        ggplot2::theme_bw() +
        ggplot2::theme(panel.spacing.x = ggplot2::unit(4, "mm"),
                       legend.position = "bottom",
                       axis.text.y = ggplot2::element_blank(),
                       axis.ticks.y = ggplot2::element_blank())
      print.ggplot(plt) |> suppressWarnings()

      # if ggplot2 is not available, original function follows
    } else {
      old_par <- graphics::par(no.readonly =TRUE)
      on.exit(graphics::par(old_par))
      start <- c(0, q_emiss * m)
      start2 <- c(0, seq(from = (q_emiss[dep]-1) * 2, to = (q_emiss[dep]-1) * 2 * m,
                         by = (q_emiss[dep]-1) * 2))
      if (missing(col)){
        cat_col <- grDevices::rainbow(q_emiss[dep])
      } else {
        cat_col <- col
      }
      if(m > 3){
        graphics::par(mfrow = c(2,ceiling(m/2)), mar = c(4,2,3,1) + 0.1, mgp = c(2,1,0))
      } else {
        graphics::par(mfrow = c(1,m), mar = c(4,2,3,1) + 0.1, mgp = c(2,1,0))
      }
      for(i in 1:m){
        # determining the scale of the y axis
        max <- 0
        for(q in 1:q_emiss[dep]){
          new <- max(stats::density(object$emiss_prob_bar[[dep]]
                                    [burn_in:J,q_emiss[dep] * (i-1) + q])$y)
          if(new > max){max <- new}
        }
        # set plotting area
        graphics::plot.default(x = 1, ylim = c(0, max), xlim = c(0,1), type = "n",
                               main = paste(dep_lab, ", state", i),
                               yaxt = "n", ylab = "", xlab = "Conditional probability", ...)
        graphics::title(ylab="Density", line=.5)
        for(q in 1:q_emiss[dep]){
          # add density curve for population level posterior distribution
          graphics::lines(stats::density(object$emiss_prob_bar[[dep]]
                                         [burn_in:J,q_emiss[dep] * (i-1) + q]),
                          type = "l", col = cat_col[q], lwd = lwd1, lty = lty1)
          # add density curves for subject posterior distributions
          for(s in 1:n_subj){
            graphics::lines(stats::density(
              object$PD_subj[[s]][burn_in:J,(sum(start[1:dep]) + (i-1)*q_emiss[dep] + q)]),
              type = "l", col = cat_col[q], lwd = lwd2, lty = lty2)
          }
        }
        graphics::legend("topright", col = cat_col, legend = cat_lab, bty = 'n',
                         lty = 1, lwd = 2, cex = .7)
      }
    }

  }
}
print.ggplot <- utils::getFromNamespace("print.ggplot", "ggplot2")
utils::globalVariables(c("id", "from_state", "to_state", "lty", "state", "category", "name", "ymax"))
