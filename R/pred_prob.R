#' Compute predicted transition/emission probabilities given certain values of a covariate
#'
#' @param object Object of class \code{mHMM}, generated by the function
#'   \code{\link{mHMM}}.
#' @param component String specifying if the prediction should be made
#'    for the transition probability matrix gamma (\code{component = "gamma"}),
#'    or for the emission distribution probabilities (\code{component = "emiss"}).
#'    In case of the latter and the model is based on multiple dependent variables,
#'    the user has to indicate a specific dependent variable, see \code{dep}.
#' @param cov Integer that specifies which covariate to use when there are
#'    multiple covariates available. The default value is 1, which
#'    indicates the first covariate in the list of covariates.
#' @param dep Integer specifying for which dependent variable the predicted
#'    emission probabilities are computed.
#' @param print.df A logical argument specifying whether the output should be
#'    returned as a dataframe (`TRUE`) or lists (`FALSE`). Default is `TRUE`.
#' @param ... Other parameters passed down to \code{pred_probs()}.
#'
#' @return Either a dataframe or lists of dataframes containing predicted
#'    transition/emission probabilities.
#'
#' @export

pred_prob <- function(object, component = "gamma", cov = 1, dep = 1, print.df = TRUE,...){
  if (!is.mHMM(object)){
    stop("The input object should be from the class mHMM, obtained with the function mHMM.")
  }
  if (component != "gamma" & component != "emiss"){
    stop("The input specified under component should be a string, restrectid to state either gamma or emiss.")
  }
  if(is.null(object$input$covar_type)){
    stop("A covariate is required for predicting either transition or emission probabilities given the covariate values.")}

  input   <- object$input
  burn_in <- input$burn_in
  J       <- input$J
  m       <- input$m
  q_emiss <- input$q_emiss
  n_dep   <- input$n_dep
  dep_labels <- input$dep_labels

  # if predict gamma
  if(component == "gamma"){
    if(dim(object$input$covariate[[1]])[2] == 1){
      stop("Please include a covariate to predict gamma.")}
    covar_gamma <- input$covariate[[1]][,cov +1]
    int <- object$gamma_int_bar
    cov <- object$gamma_cov_bar
    regr_cov <- matrix(NA, nrow = 2, ncol = m-1)
    res <- list()
      for(i in 1:m){
        regr_cov[1,] <-  apply(matrix(int[(burn_in + 1):J,(((i-1) * (m-1)) + 1) : (((i-1) * (m-1)) + m-1) ], ncol = m-1), 2, median)
        regr_cov[2,] <-  apply(matrix(cov[(burn_in + 1):J,(((i-1) * (m-1)) + 1) : (((i-1) * (m-1)) + m-1) ], ncol = m-1), 2, median)
        pred_tr2 <- list()
        for(c in 1:length(covar_gamma)){
        regr_cov[2,] <- regr_cov[2,]*covar_gamma[c]
        regr_matrix <- cbind(rep(0,2), regr_cov)
        exp_regr <- exp(apply(regr_matrix,2,sum))
        pred_tr <- as.data.frame(t(exp_regr / as.vector(exp_regr %*% c(rep(1, (length(exp_regr)))))))
        pred_tr2[[c]] <- pred_tr |>
          dplyr::rename_with(~paste0("To_state_", 1:m)) |>
          dplyr::mutate(From_state = paste("State", i),
                        covariate = covar_gamma[c],
                        dplyr::across(tidyselect::where(is.numeric), \(x) round(x, 3))
          ) |>
          dplyr::relocate(From_state, covariate)
        }
        pred_tr2 <- purrr::list_rbind(pred_tr2)
        res[[i]] <- pred_tr2
      }
    if(print.df == TRUE) res <- purrr::list_rbind(res)

    # if predict emiss
  } else if (component == "emiss"){
    if(dim(object$input$covariate[[2]])[2] == 1){
      stop("Please include a covariate to predict emission probabilities.")}
    covar_emiss <- input$covariate[[2]][,cov +1] # assuming that all DVs share the same covariates!
    dep_lab <- input$dep_labels[dep]
    int <- object$emiss_int_bar[[dep]]
    cov <- object$emiss_cov_bar[[dep]]
    res <- list()
    for(c in 1:length(covar_emiss)){
      int_mat <- cbind(rep(0, m), matrix(apply(int[((burn_in + 1): J),], 2, median), byrow = TRUE, ncol = q_emiss[dep]-1, nrow = m))
      cov_mat <- cbind(rep(0, m), matrix(apply(cov[((burn_in + 1): J),], 2, median), byrow = TRUE, ncol = q_emiss[dep]-1, nrow = m) * covar_emiss[c])

      reg_mat <- exp(int_mat + cov_mat)
      res[[c]] <- as.data.frame(t(apply(reg_mat, 1, function(x) x / as.vector(x %*% c(rep(1, length(x))))))) |>
        dplyr::rename_with(~paste("Category", 1:q_emiss[dep])) |>
        dplyr::mutate(
          State = paste("State", 1:m),
          covariate = covar_emiss[c],
          dplyr::across(tidyselect::where(is.numeric), \(x) round(x, 3))
        ) |>
        dplyr::relocate(State, covariate)
    }
    if(print.df == TRUE) res <- purrr::list_rbind(res)
    cat("Dependent variable:", dep_lab, "\n")
  }
  return(res)
}

utils::globalVariables(c("Covariate", "From_state"))
