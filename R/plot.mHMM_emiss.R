#' Plotting the emission distribution for a fitted multilevel HMM
#'
#' \code{plot.mHMM_emiss} plots the emission probability distribution for
#' a fitted multilevel hidden Markov model.
#' The plotted emission probability distributions either represents
#' the probabilities at the group level, i.e., representing the average emission
#' probability distribution over all subjects, or at the subject level.
#' In case of the latter, the user has to specify for which subject the emission
#' probability matrix should be plotted.
#'
#'
#' @param x An object of classes \code{mHMM_emiss} or \code{mHMM_emiss_cont}, generated by the function
#'   \code{\link{obtain_emiss}}.
#' @param subj_nr An integer specifying for which specific subject the
#'   transition probability matrix should be plotted. Only required if the input
#'   object represents the subject specific transition probability matrices.
#'@param by_state An optional logic variable. It indicates how user would like
#'           to display the plots. It is set to \code{TRUE} by default and it
#'           display plots state wise. If dependent variable wise presentation
#'           is preferred \code{by_state} should be set to \code{FALSE}
#'           (\code{by_state=FALSE}). To be specified only when plotting objects
#'           of class \code{mHMM_emiss}.
#' @inheritParams plot.mHMM
#' @param col An optional vector of the size of the number of categories of the
#'  dependent variable that has them the most,specifying the used colors in the
#'  \code{\link[graphics]{barplot}}.
#' @param legend_cex A numerical value giving the amount by which
#         plotting text and symbols in the legend should be magnified relative
#'        to the default.
#' @param ... Arguments to be passed to methods
#'            (see \code{\link[graphics]{barplot}})
#'
#'
#' @return \code{plot.mHMM_gamma} returns a plot of the emission probability
#'   matrix. Depending on whether the input object represents list of emission
#'   probability matrices at the group level or the subject specific list of
#'   emission probability matrices, the returned plot represents either
#'   the group emission probability distribution for each state, or the emission
#'   probability distribution for each state of given subject,
#'   specified by \code{subject_nr}.
#'
#' @seealso \code{\link{mHMM}} for fitting the multilevel hidden Markov
#'   model, creating the object \code{mHMM}, and \code{\link{obtain_emiss}} to
#'   obtain the transition probabilities gamma for a fitted multilevel HMM,
#'   creating the object \code{mHMM_gamma}.
#'
#' @examples
#' \donttest{
#'  #Discrete case
#' m <- 3 #number of states
#' n_dep <- 4 #number of dependent variables used to infer the hidden states
#' q_emiss <- c(3, 2, 3, 2) #number of categorical outcomes of
#'                           each of dependent variables
#' start_TM <- diag(.8, m) #transition matrix
#' start_TM
#' start_TM[lower.tri(start_TM) | upper.tri(start_TM)] <- .2
#' start_EM <- list(matrix(c(0.05, 0.90, 0.05,
#'                           0.90, 0.05, 0.05,
#'                          0.60, 0.30, 0.10), byrow = TRUE,
#'                        nrow = m, ncol = q_emiss[1]), # vocalizing patient
#'                 matrix(c(0.1, 0.9,
#'                          0.1, 0.9,
#'                          0.5, 0.5), byrow = TRUE, nrow = m,
#'                        ncol = q_emiss[2]), # looking patient
#'                 matrix(c(0.90, 0.05, 0.05,
#'                          0.05, 0.90, 0.05,
#'                          0.60, 0.30, 0.10), byrow = TRUE,
#'                        nrow = m, ncol = q_emiss[3]), # vocalizing therapist
#'                 matrix(c(0.1, 0.9,
#'                          0.1, 0.9,
#'                          0.5, 0.5), byrow = TRUE, nrow = m,
#'                        ncol = q_emiss[4])) # looking therapist
#'
#' out_3st <- mHMM(s_data = nonverbal,
#'                 gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
#'                 start_val = c(list(start_TM), start_EM),
#'                 mcmc = list(J = 10, burn_in = 5))
#'
#' # creating object of obtain_emiss class
#' group_emiss3<-obtain_emiss(out_3st,level = "group")
#'
#' subject_emiss3<-obtain_emiss(out_3st,level = "subject")
#'
#' #plotting
#' plot(x=subject_emiss3,subj_nr = 2)
#'
#' plot(x=group_emiss3)
#'
#' plot(x=group_emiss3,by_state=FALSE)
#'
#' #continuous case
#' n_t <- 100
#' n <- 10
#' m <- 3
#' J = 11
#' burn_in = 5
#' n_dep2 <- 2
#'
#' emiss_distr <- list(matrix(c( 5, 1,
#'                               10, 1,
#'                               15, 1), nrow = m, byrow = TRUE),
#' matrix(c(0.5, 0.1,
#'         1.0, 0.2,
#'         2.0, 0.1), nrow = m, byrow = TRUE))
#' gamma <- matrix(c(0.8, 0.1, 0.1,
#'                   0.2, 0.6, 0.2,
#'                   0.1, 0.2, 0.7), ncol = m, byrow = TRUE)
#'
#' #simulate data with continuous distribution for 2 dependent variables
#'
#' data_cont <- sim_mHMM(n_t = n_t, n = n, m = m, n_dep = n_dep2,
#'  data_distr = c('continuous','continuous'),
#' gamma = gamma, emiss_distr = emiss_distr, var_gamma = .1,
#' var_emiss = c(.5, 0.01))
#'
#' # Specify hyper-prior for the continuous emission distribution
#'
#' hyp_pr <- list(
#'  emiss_mu0 = list(matrix(c(3,7,17), nrow = 1), matrix(c(0.7, 0.8, 1.8),
#'   nrow = 1)),
#'  emiss_K0  = list(1, 1),
#'  emiss_nu  = list(1, 1),
#'  emiss_V   = list(rep(2, m), rep(1, m)),
#'  emiss_a0  = list(rep(1, m), rep(1, m)),
#'  emiss_b0  = list(rep(1, m), rep(1, m)))
#'
#'# Fit the mHMM_cont on 2 dep variable data:
#'
#' out_3st_cont_sim <- mHMM_cont(s_data = data_cont$obs,
#'                              gen = list(m = m, n_dep = n_dep2),
#'                              start_val = c(list(gamma), emiss_distr),
#'                              emiss_hyp_prior = hyp_pr,
#'                              mcmc = list(J = J, burn_in =burn_in,
#'                              show_progress = FALSE))
#'
#' emiss1_g_cont <- obtain_emiss(out_3st_cont_sim)
#'
#'
#' plot.mHMM_emiss(emiss1_g_cont)
#'
#'}
#'
#' @export

plot.mHMM_emiss<- function(x,subj_nr=NULL,by_state=TRUE,cat_lab,
                           dep_lab,col,legend_cex=1,...){


  #------ set to default plot space size-------#
  k=c(5.1,4.1,4.1,2.1)
  par(mar=k)
  empty<-c()

  #-----Here the class checked----------------#
  if (!is.mHMM_emiss(x) && !is.mHMM_emiss_cont(x)){
    stop("The input object x should be from the mHMM_emiss or mHMM_emiss_cont class, obtained with the function obtain_emiss.")
  }


  #-----n_dep is number of elements of list x---#
  n_dep<-length(x)


  q_emiss<-c()
  m<-c()

  if (isNested(x)==T){

    if (is.null(subj_nr)){
      stop("When the input object x represents the subject specific transition
           probability matrices, the subject for which the probabilities should
           be plotted needs to be specified with the input variable -subj_nr-.")
    }else{
      new<-list()
      for(n in 1:n_dep){
        new[[n]]<-x[[n]][[subj_nr]]
        x[[n]]<-new[[n]]
      }



 #-----calculating m(number of states) and q_emiss(vector representing number of categories for each dep. variable) for subject level----#
      m<-dim(x[[1]])[1]

      if(is.mHMM_emiss(x)){
        for(b in 1:n_dep){
        q_emiss[b]<-dim(x[[b]])[2]
      }
      }
    }

  }else{

    if(!is.null(subj_nr)){
      warning("The subject number can only be specified when plotting the subject level transition probabilities. Currently, the group level transition probabilities are plotted.")
    }

#------calculating m(number of states) and q_emiss(vector representing number of categories for each dep. variable) for subject level-----#
    m<- dim(x[[1]])[1]
    if(is.mHMM_emiss(x)){
      for(l in 1:n_dep){
      q_emiss[l]<-dim(x[[l]])[2]
    }
    }
    new<-list()
    new<-x

  }
  if (missing(dep_lab)){
        names(x)<- names(x)
      } else {
        if (!is.vector(dep_lab) | length(dep_lab) != n_dep){
          stop("When specifying group labels, in -dep_lab-.The variable has to be a vector
             with lenght equal to the number of dependent variables ",n_dep,".")
        }
        }
  #Plugging specified by user dependent variable labels
  if(!missing(dep_lab) && length(dep_lab)==max(n_dep)){
    for (k in which(!is.na(dep_lab))) {
      names(x)[k]<-dep_lab[k]
    }
  }


  if(is.mHMM_emiss(x)){


#------Plugging specified by user category labels---#
  if (missing(cat_lab)==T){
    for(k in n_dep){
      colnames(new[[k]])<-colnames(new[[k]])
    }
  }else if(!is.list(cat_lab) | length(cat_lab) != n_dep | sum(lengths(cat_lab) != q_emiss) > 0){
    stop(paste0("cat_lab should be a list with n_dep (", n_dep, ") elements, each containing a vector with lengths ", paste(q_emiss, collapse = ", "), ", respectively."))
  }

  if(!missing(cat_lab)){
    for(q in which(!is.na(cat_lab))){
        colnames(new[[q]]) <-cat_lab[[q]]
      }
    }




#------Color setting------#
  if(missing(col)){
    n_col<- max(q_emiss)
    if(n_col<=8){
      if("RColorBrewer" %in% (.packages())){
        coul<-brewer.pal(n_col,"Dark2")
      }else{

        coul<-grDevices::rainbow(n_col, s = 1, v = 1, start = 0, end = max(1, n_col - 1)/n_col, alpha = 1)
      }
    }else if(n_col>8 && n_col<=12){
      if("RColorBrewer" %in% (.packages())){
        coul<-brewer.pal(n_col,"Paired")
      }else{

        coul<-grDevices::rainbow(n_col, s = 1, v = 1, start = 0, end = max(1, n_col - 1)/n_col, alpha = 1)
      }
    }else{
      coul<-grDevices::rainbow(n_col, s = 1, v = 1, start = 0, end = max(1, n_col - 1)/n_col, alpha = 1)
      warning("To plot the emission distribution for dependent variables that contain more than 12 categories \n
              with more appealing colours, specify your own vector of colours.")
    }



  }else if(!missing(col)){
    if(length(col)!=max(q_emiss)){
      stop("When specifying colour vector, in -col-.The variable has to be a vector
             with lenght equal to the maximum number of dependent variables cathegories ",max(q_emiss),".")
    }else{
      coul<-col
    }
  }


# --- by_state==TRUE meaning that the plots will be displayed for each state---#
  if(by_state==TRUE){
#----Set the emission_states list where each object presents emission probabilities of all dependent variables for each state-----#
    emission_states<-list()
    data<-matrix(nrow=n_dep,ncol=max(q_emiss))
    for(s in 1:m){
      for(j in 1:n_dep){
        while(ncol(x[[j]])!=max(q_emiss)) x[[j]]<-cbind(x[[j]],0)
        data[j,]<-x[[j]][s,]
      }
      data<-as.data.frame(data)
      row.names(data)<-c(names(x))
      emission_states[[s]]<-as.data.frame(data)
      data<-matrix(nrow=n_dep,ncol=max(q_emiss))
    }
    a<-emission_states

#----Plotting grid setting---#
    if(m>3){
      pre_grid<-matrix(NA,5,ceiling(m/2))
      extra <-matrix(NA, 5, ceiling(m/4))

      pre_grid[1,]<-rep(ceiling(m/2)*2+ceiling(n_dep/4)*4+1,ceiling(m/2))
      pre_grid[2,]<-c(1:ceiling(m/2))
      pre_grid[3,]<-pre_grid[2,]
      pre_grid[4,]<-c((ceiling(m/2)+1):(ceiling(m/2)*2))
      pre_grid[5,]<-pre_grid[4,]

      for(i in 1:ceiling(n_dep/4)){

        extra[,i]<-c(ceiling(m/2)*2+ceiling(n_dep/4)*4+1,ceiling(m/2)*2+(i*4)-3
                     ,ceiling(m/2)*2+(i*4)-2,ceiling(m/2)*2+(i*4)-1,ceiling(m/2)*2+(i*4))
      }
      new_grid<-cbind(pre_grid,extra)


    }else{

      new_grid<-matrix(NA,1+n_dep, m+1)
      new_grid[1,]<-rep(m+n_dep+1,m+1)

      for (r in 1:n_dep+1) {
        new_grid[r,]<-c(1:m,m+r-1)
      }

      new_grid[1,]<-rep(m+n_dep+1,m+1)

    }
    graphics::layout(new_grid)

#----here we plot for only 3 states but if we will want to plot 5 then after m plots there has to be ceiling(m/2)*2-m more empty plots----#
    for(j in 1:m){
      if(is.null(subj_nr)==F){
        main_sub<-paste("Subject ",subj_nr)
        graphics::barplot(t(a[[j]]),main=paste("state",j),yaxt="n",legend=F, col=coul,las=2,...)
      }
      else{
        graphics::barplot(t(a[[j]]),main=paste("state",j),yaxt="n",legend=F, col=coul,las=2,...)
      }
    }
    if(m>3){
      empty<-((ceiling(m/2)*2)-m)
      while(empty>0){
        graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
        empty=empty-1
      }
    }

    old<-graphics::par("mai")
    graphics::par(mar=old)

 #----there is ceiling(n_dep/4)*4 inputs so add ceiling(n_dep/4)*4-n_dep empty plots----#
    for(p in 1:n_dep){
      graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
      if(is.null(subj_nr)==F){
        graphics::legend("center",legend=colnames(new[[p]]),fill=coul,title=names(x[p]),cex =legend_cex,bty="n") #here I checked
      }else{
        graphics::legend("center",legend=colnames(new[[p]]),fill=coul,title=names(x[p]),cex =legend_cex,bty="n")
      }
    }

    if(m>3){
      empty<-((ceiling(n_dep/4)*4)-n_dep)
      while(empty>0) {
        graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
        empty=empty-1
      }
    }

    graphics::par(mar=old)

    graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
    if(is.null(subj_nr)==F){
      main_sub<-paste("subject ",subj_nr)
      graphics::text(x=1,y=0, paste("Emission probability distributions by states for",main_sub), cex = 2, col = "black")
    }else{
      graphics::text(x=1,y=0, paste("Group emission probability distributions by states"), cex = 2, col = "black")
    }
 #----- Here when we want to plot grouping by dependent variable----#
  }else if(by_state==FALSE){

    if(n_dep>3){
      pre_grid<-matrix(NA,5,ceiling(n_dep/2))
      pre_grid[1,]<-rep(ceiling(n_dep/2)*2+ceiling(n_dep/4)*4+1,ceiling(n_dep/2))
      extra <-matrix(NA, 5, ceiling(n_dep/4))

      pre_grid[2,]<-c(1:ceiling(n_dep/2))
      pre_grid[3,]<-c(1:ceiling(n_dep/2))
      pre_grid[4,]<-c((ceiling(n_dep/2)+1):(ceiling(n_dep/2)*2))
      pre_grid[5,]<-c((ceiling(n_dep/2)+1):(ceiling(n_dep/2)*2))

      for(i in 1:ceiling(n_dep/4)){

        extra[,i]<-c(ceiling(n_dep/2)*2+ceiling(n_dep/4)*4+1,ceiling(n_dep/2)*2+(i*4)-3
                     ,ceiling(n_dep/2)*2+(i*4)-2,ceiling(n_dep/2)*2+(i*4)-1,ceiling(n_dep/2)*2+(i*4))
      }
      new_grid<-cbind(pre_grid,extra)

    }else{
      new_grid<-matrix(NA,1+n_dep, n_dep+1)
      new_grid[1,]<-rep((n_dep)*2+1,n_dep+1)
      for (r in 2:(1+n_dep)) {
        new_grid[r,]<-c(1:n_dep,n_dep+r-1)
      }
    }
    graphics::layout(new_grid)
 #--here we plot for only 3 states but if we will want to plot 5 then after m plots there has to be ceiling(m/2)*2-m more empty plots
    for(j in 1:n_dep){
      if(is.null(subj_nr)==F){
 #------change the source of title
        main_sub<-paste("Subject ",subj_nr)
        graphics::barplot(t(x[[j]]),main=names(x)[j],yaxt="n",legend=F, col=coul,las=2,...)
      }
      else{
        graphics::barplot(t(x[[j]]),main=names(x)[j],yaxt="n",legend=F, col=coul,las=2,...)
      }
    }
    if(n_dep>3){
      empty<-((ceiling(n_dep/2)*2)-n_dep)
      while(empty>0) {
        graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
        empty=empty-1
      }
    }
    old<-graphics::par("mai")
    graphics::par(mar=old)

 #----there is ceiling(n_dep/4)*4 imputs so add ((ceiling(n_dep/4)*4)-n_dep) empty plots----#
    for(p in 1:n_dep){
      graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
      if(is.null(subj_nr)==F){
        graphics::legend("center",legend=colnames(new[[p]]),fill=coul,title=names(x[p]),cex =legend_cex,bty="n")
      }else{
        graphics::legend("center",legend=colnames(new[[p]]),fill=coul,title=names(x[p]),cex =legend_cex,bty="n")
      }
    }
    if(n_dep>3){
      empty<-((ceiling(n_dep/4)*4)-n_dep)
      while(empty>0) {
        graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
        empty=empty-1
      }
    }

    graphics::par(mar=old)

    graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
    if(is.null(subj_nr)==F){
      main_sub<-paste("subject ",subj_nr)
      graphics::text(x=1,y=0, paste("Emission probability distributions by dependent variables for",main_sub), cex = 2, col = "black")
    }else{
      graphics::text(x=1,y=0, paste("Group emission probability distributions by dependent variables"), cex = 2, col = "black")
    }
  }




  }else if(is.mHMM_emiss_cont(x)){

 #----Color setting-----#
    if(missing(col)){
      n_col<- m
      if(n_col<=8){
        if("RColorBrewer" %in% (.packages())){
          coul<-brewer.pal(n_col,"Dark2")
        }else{

          coul<-grDevices::rainbow(n_col, s = 1, v = 1, start = 0, end = max(1, n_col - 1)/n_col, alpha = 1)
        }
      }else if(n_col>8 && n_col<=12){
        if("RColorBrewer" %in% (.packages())){
          coul<-brewer.pal(n_col,"Paired")
        }else{

          coul<-grDevices::rainbow(n_col, s = 1, v = 1, start = 0, end = max(1, n_col - 1)/n_col, alpha = 1)
        }
      }else{
        coul<-grDevices::rainbow(n_col, s = 1, v = 1, start = 0, end = max(1, n_col - 1)/n_col, alpha = 1)
        warning("To plot the emission distributions for more than 12 states, specify your own vector of colours to make the plots more appealing.")
      }
      }else if(!missing(col)){
        if(length(col)!=m){
          stop("When specifying colour vector, in -col-.The variable has to be a vector
             with lenght equal to the number of states ",m,".")
        }else{
          coul<-col
        }
      }
#---save the object of class "mHMM_emiss_cont" under a new variable "a"
    a<-x

 #---set the grid of the plotting space #maybe I should put the legend separately----#
    if(n_dep>3){
      new_grid<-matrix(NA,5,ceiling(n_dep/2))
      new_grid[1,]<-rep(ceiling(n_dep/2)*2+1,ceiling(n_dep/2))
      new_grid[2,]<-c(1:ceiling(n_dep/2))
      new_grid[3,]<-new_grid[2,]
      new_grid[4,]<-c((ceiling(n_dep/2)+1):(ceiling(n_dep/2)*2))
      new_grid[5,]<-new_grid[4,]

      }else{
        new_grid<-matrix(NA,5, n_dep)
        new_grid[1,]<-rep(n_dep+1,n_dep)

      for (r in 2:5) {
        new_grid[r,]<-c(1:n_dep)
      }
         }

    graphics::layout(new_grid)
      y=list()


    for(i in 1:n_dep){
      a[[i]][,2]<-sqrt(a[[i]][,2])
      mu_range_min<-min(a[[i]][,1])
      mu_range_max<-max(a[[i]][,1])
      sigma_range<-max(a[[i]][,2])
      range<-seq(mu_range_min-3*sigma_range,mu_range_max+3*sigma_range,0.01)

      for(n in 1:m){
      y[[n]]<-dnorm(range,mean =a[[i]][[n,1]],sd =a[[i]][[n,2]] )

      }
      new<-unlist(y)
      new_ylim<-max(new)

      graphics::plot(range,y[[1]],ylim=c(0,new_ylim+0.05),xlim=c(min(range),max(range)),col=coul[1],type="l",ylab ="",xlab = "",main=paste(names(x)[i]),lwd=3)
      graphics::polygon(range,y[[1]], col=t_col(coul[1]))
      for(k in 2:m){
        graphics::lines(range,y[[k]],col=coul[k],lwd=3)
        graphics::polygon(range,y[[k]], col= t_col(coul[k]))
      }
      if(n_dep<=3){
        if(i==n_dep){
          graphics::legend("topright",legend=row.names(x[[1]]),fill=coul,title = "States",bty="n",cex =legend_cex)
        }

      }else
        if(i==ceiling(n_dep/2)){
          graphics::legend("topright",legend=row.names(x[[1]]),fill=coul,title = "States",bty="n",cex =legend_cex)

        }

    }


  if(n_dep>3){
    empty<-((ceiling(n_dep/2)*2)-n_dep)
    while(empty>0) {
      graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
      empty=empty-1
    }
  }
      old<-graphics::par("mai")
      graphics::par(mar=old)

      graphics::plot(0,type='n',axes=FALSE,ann=FALSE)
      if(!is.null(subj_nr)){
        graphics::text(x=1,y=0, paste("Emission probability distributions by dependent variables for subject ",subj_nr), cex = 2, col = "black")
      }else{
        graphics::text(x=1,y=0, paste("Group emission probability distributions by dependent variables"), cex = 2, col = "black")
      }
}




  graphics::par(mfrow=c(1,1))
}





