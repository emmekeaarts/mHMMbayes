#' Plotting the traceplot(s) corresponding to one or more Markov chains
#'
#' \code{traceplot.mHMM} creates the traceplots for the group-level parameter
#'    estimates corresponding to a fitted multilevel hidden Markov model.
#'
#' @param L a list of objects of class \code{mHMM} generated by the
#'    \code{\link{mHMM}} function.
#' @param component A string is used to specify whether the traceplot should be
#'    created for the parameter estimates of the transition probabilities
#'    (\code{component = "gamma"}) or the emission probabilities
#'    (\code{component = "emiss"}). When the component is `"emiss"` and
#'    the model is based on multiple dependent variables, the user must indicate
#'    a specific dependent variable to be plotted using dep, see \code{dep}.
#' @param dep Integer specifying for which dependent variable the traceplot
#'     should be plotted. Only required if one wishes to plot the
#'    emission distribution probabilities and the model is based on multiple
#'    dependent variables.
#' @param cat_lab Optional vector of strings when plotting for the emission
#'    probabilities, denoting the labels of the categorical outcome values.
#'    Automatically generated when not provided.
#' @param dep_lab Optional string when plotting for the emission probabilities,
#'    denoting the label for the dependent variable plotted.
#'    Automatically obtained from the input object \code{x} when not specified.
#' @param burn_in An integer which specifies the number of iterations to discard.
#'    When left unspecified, the burn in period specified at creating the
#'    \code{mHMM} object with the function \code{\link{mHMM}} will be used.
#'
#' @export
#'
traceplot <- function(L, component = "gamma", dep = 1, cat_lab,
                           dep_lab, burn_in, ...){
  if(!any(sapply(L, is.mHMM))){
    stop("Every input object of list L should be from the class mHMM, obtained with the function mHMM.")
  }
  if (component != "gamma" & component != "emiss"){
    stop("The input specified under component should be a string, restrectid to state either gamma or emiss.")
  }
  if (missing(burn_in)){
    burn_in <- L[[1]]$input$burn_in
  }
  J <- L[[1]]$input$J
  if (burn_in >= (J-1)){
    stop(paste("The specified burn in period should be at least 2 points smaller
               compared to the number of iterations J, J =", J))
  }
  # old_par <- graphics::par(no.readonly =TRUE)
  # on.exit(graphics::par(old_par))
  m       <- L[[1]]$input$m
  q_emiss <- L[[1]]$input$q_emiss
  n_dep   <- L[[1]]$input$n_dep
  nchain <- length(L)

  # if plotting gamma
  if(component == "gamma"){
    # # when ggplot2 & dplyr are available
    # if(nzchar(system.file(package = "ggplot2")) && nzchar(system.file(package = "dplyr"))){
      # extract gamma matrices
      object <- purrr::map_dfr(1:length(L), ~ {
        L[[.x]]["gamma_prob_bar"]|>
          as.data.frame() |>
          dplyr::rename_with(~sub(".*bar.", "", .x)) |>
          dplyr::mutate(iteration = dplyr::row_number()) |>
          dplyr::slice(-(1:burn_in))
      } , .id="chain") |>
        tidyr::pivot_longer(!c(chain, iteration), names_to = "states", values_to = "value")

      # create traceplots
      if (nchain <= 1) {
        f <- ggplot2::ggplot(object, ggplot2::aes(x = iteration, y = value))
      } else {
        f <- ggplot2::ggplot(object, ggplot2::aes(x = iteration, y = value,
                                                  colour = as.factor(chain)))
      }
      f <- f + ggplot2::geom_line(alpha = 0.7, size = 0.3) +
        ggplot2::facet_wrap(~ states, scales = "free") +
        ggplot2::scale_color_brewer(palette = "Set2", name = "Chain") +
        ggplot2::labs(title = "Parameter estimates of transition probabilities",
                      subtitle = "At the group level", y = "") +
        ggplot2::theme_bw() +
        ggplot2::theme(legend.position = "bottom")

    #   # when ggplot2 is not available, use baseR
    # } else {
    #   if (missing(col)){
    #     state_col <- grDevices::rainbow(m)
    #   } else {
    #     state_col <- col
    #   }
    #   # specify layout
    #   graphics::par(mfrow = c(m * m, 1))
    #   # graphics::par(mfrow = c(2, ceiling(m/2)), mar = c(4,2,3,1) + 0.1, mgp = c(2,1,0))
    #   f <- for(i in 1:m){
    #     # find min and max y
    #     maxy <- miny <- 0
    #     for(j in 1:m){
    #       newmax <- max(sapply(L, function(x) max(x$gamma_prob_bar[burn_in:J, m * (i-1) + j])))
    #       newmin <- min(sapply(L, function(x) min(x$gamma_prob_bar[burn_in:J, m * (i-1) + j])))
    #       if(newmax > maxy) maxy <- newmax
    #       if(newmin < miny) miny <- newmin
    #     }
    #     for(j in 1:m){
    #       graphics::plot.default(x = 1, xlim = c(burn_in, J), ylim = c(miny, maxy), type = "n", cex = .8,
    #                              ylab = "transition probability", xlab = "iteration")
    #       for(k in 1:nchain){
    #         graphics::lines(x = burn_in:J, y = L[[k]]$gamma_prob_bar[burn_in:J, m * (i-1) + j],
    #                         ylab = "transition probability",
    #                         xlab = "iteration", col = state_col[k])
    #       }
    #       graphics::title(main = paste("From state", i, "to State", j))
    #       graphics::legend("topright", col = state_col, legend = paste("Chain", 1:nchain),
    #                        bty = 'n', lty = 1, lwd = 2, cex = .8)
    #     }
    #   }
    # }

    # if plotting emiss
  } else if (component == "emiss"){
    if (missing(cat_lab)){
      cat_lab <- paste("Category", 1:q_emiss[dep])
    }
    if (missing(dep_lab)){
      dep_lab <- L[[1]]$input$dep_labels[dep]
    }
    # # if ggplot2 and dplyr are available
    # if(nzchar(system.file(package = "ggplot2")) && nzchar(system.file(package = "dplyr"))){
      # extract emission prob matrices
      object <- purrr::map_dfr(1:length(L), ~ {
        L[[.x]]$emiss_prob_bar[[dep]] |>
          as.data.frame() |>
          dplyr::rename_with(~stringi::stri_replace_all_regex(
            .x, pattern = paste0("Emiss", 1:q_emiss[dep]), replacement = cat_lab)) |>
          dplyr::mutate(iteration = dplyr::row_number()) |>
          dplyr::slice(-(1:burn_in))
      } , .id="chain") |>
        tidyr::pivot_longer(!c(chain, iteration), names_to = "states", values_to = "value")
      # create traceplots
      if (nchain <= 1) {
        f <- ggplot2::ggplot(object, ggplot2::aes(x = iteration, y = value))
      } else {
        f <- ggplot2::ggplot(object, ggplot2::aes(x = iteration, y = value,
                                                  colour = as.factor(chain)))
      }
      f <- f + ggplot2::geom_line(alpha = 0.7, size = 0.3) +
        ggplot2::facet_wrap(~ states, scales = "free") +
        ggplot2::scale_color_brewer(palette="Set2", name = "Chain") +
        ggplot2::labs(title = paste("Parameter estimates of emission
                                    probabilities for", dep_lab),
                      subtitle = "At the group level", y = "") +
        ggplot2::theme_bw() +
        ggplot2::theme(legend.position = "bottom")

    #   # if ggplot2 is not available, use baseR
    # } else {
    #   # specify layout
    #   graphics::par(mfrow = c(m * q_emiss[dep], 1))
    #
    #   f <- for(i in 1:m){
    #     # find min and max y
    #     maxy <- miny <- 0
    #     for(q in 1:q_emiss[dep]){
    #       newmax <- max(sapply(L, function(x) max(x$emiss_prob_bar[[dep]]
    #                                               [burn_in:J,q_emiss[dep] * (i-1) + q])))
    #       newmin <- min(sapply(L, function(x) min(x$emiss_prob_bar[[dep]]
    #                                               [burn_in:J,q_emiss[dep] * (i-1) + q])))
    #       if(newmax > maxy) maxy <- newmax
    #       if(newmin < miny) miny <- newmin
    #     }
    #     for(q in 1:q_emiss[dep]){
    #       graphics::plot.default(x = 1, ylim = c(miny, maxy), xlim = c(burn_in, J), type = "n", cex = .8,
    #                              ylab = "emission probability", xlab = "iteration")
    #       for(k in 1:nchain){
    #         graphics::lines(x = burn_in:J, y = L[[k]]$emiss_prob_bar[[dep]]
    #                         [burn_in:J, (i-1) * q_emiss[dep] +q], col = state_col[k])
    #       }
    #       graphics::title(main = paste(dep_lab, cat_lab[q], "in State", i))
    #       graphics::legend("topright", col = state_col, legend = paste("Chain", 1:nchain),
    #                        bty = 'n', lty = 1, lwd = 2, cex = .8)
    #     }
    #   }
    # }
  }
  return(f)
}

utils::globalVariables(c("chain", "iteration", "value"))
