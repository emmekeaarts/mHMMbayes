#' Plotting the traceplot(s) corresponding to one or more Markov chains
#'
#' \code{traceplot} creates the traceplot(s) for the group-level parameter
#'    estimates corresponding to a fitted multilevel hidden Markov model.
#'
#' @param L a list of objects of class \code{mHMM} generated by the
#'    \code{\link{mHMM}} function.
#' @param component A string is used to specify whether the traceplot should be
#'    created for the parameter estimates of the transition probabilities
#'    (\code{component = "gamma"}) or the emission probabilities
#'    (\code{component = "emiss"}). When the component is `"emiss"` and
#'    the model is based on multiple dependent variables, the user must indicate
#'    a specific dependent variable to be plotted using dep, see \code{dep}.
#' @param dep Integer specifying for which dependent variable the traceplot
#'     should be plotted. Only required if one wishes to plot the
#'    emission distribution probabilities and the model is based on multiple
#'    dependent variables.
#' @param col Optional vector of colors for the traceplot lines. The vector
#'    should have a length equal to the number of \code{mHMM} objects in the
#'    list \code{L}. If not specified, colors will be automatically assigned.
#' @param cat_lab Optional vector of strings when plotting for the emission
#'    probabilities, denoting the labels of the categorical outcome values.
#'    Automatically generated when not provided.
#' @param dep_lab Optional string when plotting for the emission probabilities,
#'    denoting the label for the dependent variable plotted.
#'    Automatically obtained from the input object \code{L} when not specified.
#' @param burn_in An integer which specifies the number of iterations to discard.
#'    When left unspecified, the burn in period specified at creating the
#'    \code{mHMM} object with the function \code{\link{mHMM}} will be used.
#' @param ... Other parameters passed down to \code{traceplot()}.
#'
#' @export

traceplot <- function(L, component = "gamma", dep = 1, col, cat_lab,
                      dep_lab, burn_in, ...){
  if(!any(sapply(L, is.mHMM))){
    stop("Every input object of list L should be from the class mHMM, obtained with the function mHMM.")
  }
  if (component != "gamma" & component != "emiss"){
    stop("The input specified under component should be a string, restrectid to state either gamma or emiss.")
  }
  if (missing(burn_in)){
    burn_in <- L[[1]]$input$burn_in
  }
  J <- L[[1]]$input$J
  if (burn_in >= (J-1)){
    stop(paste("The specified burn in period should be at least 2 points smaller
               compared to the number of iterations J, J =", J))
  }
  m       <- L[[1]]$input$m
  q_emiss <- L[[1]]$input$q_emiss
  n_dep   <- L[[1]]$input$n_dep
  nchain <- length(L)
  if (missing(col)){
    col <- scales::hue_pal()(nchain)
  } else {col <- col}
  # if plotting gamma
  if(component == "gamma"){
    # when ggplot2 is available
    if(nzchar(system.file(package = "ggplot2"))){
      # extract gamma matrices
      object <- purrr::map_dfr(1:length(L), ~ {
        L[[.x]]["gamma_prob_bar"]|>
          as.data.frame() |>
          dplyr::rename_with(~sub(".*bar.", "", .x)) |>
          dplyr::mutate(iteration = dplyr::row_number()) |>
          dplyr::slice(-(1:burn_in))
      } , .id="chain") |>
        tidyr::pivot_longer(!c(chain, iteration), names_to = "states",
                            values_to = "value") |>
        dplyr::mutate(dplyr::across(states, stringi::stri_replace_all_regex,
                                    pattern = c("S", "to"),
                                    replacement = c("State", " to "),
                                    vectorize_all=FALSE))

      # create traceplots
      if (nchain <= 1) {
        f <- ggplot2::ggplot(object, ggplot2::aes(x = iteration, y = value))
      } else {
        f <- ggplot2::ggplot(object, ggplot2::aes(x = iteration, y = value,
                                                  colour = as.factor(chain)))
      }
      f + ggplot2::geom_line(alpha = 0.7, linewidth = 0.3) +
        ggplot2::facet_wrap(~states,  scales = "free", labeller = ggplot2::as_labeller(
          function(string, prefix = "From") paste(prefix, string))) +
        ggplot2::scale_color_manual(values = col, name = "Chain") +
        ggplot2::labs(title = "Parameter estimates of transition probabilities",
                      subtitle = "At the group level", y = "") +
        ggplot2::theme_bw() +
        ggplot2::theme(legend.position = "bottom")

      # when ggplot2 is not available, use baseR
    } else {
      old_par <- graphics::par(no.readonly =TRUE)
      on.exit(graphics::par(old_par))
      if (missing(col)){
        state_col <- grDevices::rainbow(m)
      } else {
        state_col <- col
      }
      # specify layout
      # graphics::par(mfrow = c(m * m, 1))
      graphics::par(mfrow = c(2, ceiling(m/2)), mar = c(4,2,3,1) + 0.1, mgp = c(2,1,0))
      for(i in 1:m){
        # find min and max y
        maxy <- miny <- 0
        for(j in 1:m){
          newmax <- max(sapply(L, function(x) max(x$gamma_prob_bar[burn_in:J, m * (i-1) + j])))
          newmin <- min(sapply(L, function(x) min(x$gamma_prob_bar[burn_in:J, m * (i-1) + j])))
          if(newmax > maxy) maxy <- newmax
          if(newmin < miny) miny <- newmin
        }
        for(j in 1:m){
          graphics::plot.default(x = 1, xlim = c(burn_in, J), ylim = c(miny, maxy), type = "n", cex = .8,
                                 ylab = "transition probability", xlab = "iteration")
          for(k in 1:nchain){
            graphics::lines(x = burn_in:J, y = L[[k]]$gamma_prob_bar[burn_in:J, m * (i-1) + j],
                            ylab = "transition probability",
                            xlab = "iteration", col = state_col[k])
          }
          graphics::title(main = paste("From state", i, "to State", j))
          graphics::legend("topright", col = state_col, legend = paste("Chain", 1:nchain),
                           bty = 'n', lty = 1, lwd = 2, cex = .8)
        }
      }
    }

    # if plotting emiss
  } else if (component == "emiss"){
    if (missing(cat_lab)){
      cat_lab <- paste("Category", 1:q_emiss[dep])
    }
    if (missing(dep_lab)){
      dep_lab <- L[[1]]$input$dep_labels[dep]
    }
    # if ggplot2 is available
    if(nzchar(system.file(package = "ggplot2"))){
      # extract emission prob matrices
      object <- purrr::map_dfr(1:length(L), ~ {
        L[[.x]]$emiss_prob_bar[[dep]] |>
          as.data.frame() |>
          dplyr::rename_with(~stringi::stri_replace_all_regex(
            .x, pattern = paste0("Emiss", 1:q_emiss[dep]), replacement = cat_lab)) |>
          dplyr::mutate(iteration = dplyr::row_number()) |>
          dplyr::slice(-(1:burn_in))
      } , .id="chain") |>
        tidyr::pivot_longer(!c(chain, iteration), names_to = "states",
                            values_to = "value") |>
        dplyr::mutate(dplyr::across(states, stringr::str_replace, "S", "State "))

      # create traceplots
      if (nchain <= 1) {
        f <- ggplot2::ggplot(object, ggplot2::aes(x = iteration, y = value))
      } else {
        f <- ggplot2::ggplot(object, ggplot2::aes(x = iteration, y = value,
                                                  colour = as.factor(chain)))
      }
      f + ggplot2::geom_line(alpha = 0.7, linewidth = 0.3) +
        ggplot2::facet_wrap(~ states, scales = "free") +
        ggplot2::scale_color_manual(values = col, name = "Chain") +
        ggplot2::labs(title = paste("Parameter estimates of emission probabilities for",
                                    dep_lab), subtitle = "At the group level", y = "") +
        ggplot2::theme_bw() +
        ggplot2::theme(legend.position = "bottom")

      # if ggplot2 is not available, use baseR
    } else {
      old_par <- graphics::par(no.readonly =TRUE)
      on.exit(graphics::par(old_par))
      # specify layout
      # graphics::par(mfrow = c(m * q_emiss[dep], 1))
      graphics::par(mfrow = c(2, ceiling(m/2)), mar = c(4,2,3,1) + 0.1, mgp = c(2,1,0))

      for(i in 1:m){
        # find min and max y
        maxy <- miny <- 0
        for(q in 1:q_emiss[dep]){
          newmax <- max(sapply(L, function(x) max(x$emiss_prob_bar[[dep]]
                                                  [burn_in:J,q_emiss[dep] * (i-1) + q])))
          newmin <- min(sapply(L, function(x) min(x$emiss_prob_bar[[dep]]
                                                  [burn_in:J,q_emiss[dep] * (i-1) + q])))
          if(newmax > maxy) maxy <- newmax
          if(newmin < miny) miny <- newmin
        }
        for(q in 1:q_emiss[dep]){
          graphics::plot.default(x = 1, ylim = c(miny, maxy), xlim = c(burn_in, J), type = "n", cex = .8, ylab = "emission probability", xlab = "iteration")
          for(k in 1:nchain){
            graphics::lines(x = burn_in:J, y = L[[k]]$emiss_prob_bar[[dep]]
                            [burn_in:J, (i-1) * q_emiss[dep] +q], col = state_col[k])
          }
          graphics::title(main = paste(dep_lab, cat_lab[q], "in State", i))
          graphics::legend("topright", col = state_col, legend = paste("Chain", 1:nchain),
                           bty = 'n', lty = 1, lwd = 2, cex = .8)
        }
      }
    }
  }
}

utils::globalVariables(c("chain", "iteration", "value", "states"))
