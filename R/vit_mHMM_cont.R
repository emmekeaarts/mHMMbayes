#' Obtain hidden state sequence for each subject using the Viterbi
#' algorithm
#'
#' \code{vit_mHMM_tr_cont} obtains the most likely state sequence (for each subject)
#' from an object of class \code{mHMM_tr_cont} (generated by the
#' function \code{mHMM_tr_cont()} for sequences obtained from multiple subjects or animals,
#' respectively), using (an extended version of) the Viterbi algorithm. This is
#' also known as global decoding.
#'
#' Note that local decoding is also possible, by inferring the most frequent
#' state at each point in time for each subject from the sampled state path at
#' each iteration of the MCMC algorithm. This information is contained in the
#' output object \code{return_path} of the function \code{mHMM_tr_cont()}.
#'
#' @param object An object of class \code{mHMM_tr_cont}, generated by the
#'   function \code{\link{mHMM_tr_cont}}, respectively.
#' @inheritParams mHMM
#' @param burn_in The number of iterations to be discarded from the MCMC
#'   algorithm when inferring the transition probability matrix gamma and the
#'   emission distribution of (each of) the dependent variable(s) for each
#'   subject from \code{s_data}. If omitted, defaults to \code{NULL} and
#'   \code{burn_in} specified at the function \code{mHMM} will be used.
#'
#' @return The function \code{vit_mHMM_tr_cont} returns a matrix containing the most
#'   likely state at each point in time. Each column represents a subject, and
#'   each row represents a point in time. If sequence lengths differ over
#'   subjects, states for none existing time points for subjects are filled with
#'   \code{NA}.
#'
#' @export


vit_mHMM_tr_cont <- function(object, s_data, burn_in = NULL){

  if (!("mHMM_tr_cont" %in% class(object))){
    stop("The input object used should be from the class mHMM_tr_cont, obtained by using the function mHMM_tr_cont.")
  }
  # if (!is.mHMM_tr_cont(object)){ ## THIS VERSION PRODUCES AN ERROR
  #   stop("The input object used should be from the class mHMM_tr_cont, obtained by using the function mHMM_tr_cont.")
  # }
  id         <- unique(s_data[,1])
  n_subj     <- length(id)
  if(length(object$PD_subj) != n_subj){
    stop("s_data used should be from the same subjects used for creating the object in mHMM.
         The number of subjects in the datasets are not the same.")
  }
  n_vary     <- table(s_data[,1])
  max_n      <- max(n_vary)
  state_seq  <- matrix(,ncol = n_subj, nrow = max_n)

  input      <- object$input
  n_dep      <- input$n_dep
  m          <- input$m
  q_emiss    <- input$q_emiss
  if(is.null(burn_in)){
    burn_in  <- input$burn_in
  }
  J          <- input$J
  if (burn_in >= (J-1)){
    stop(paste("The specified burn in period should be at least 2 points smaller
               compared to the number of iterations J, J =", J))
  }
  est_emiss  <- rep(list(rep(list(matrix(,nrow = m, ncol = 2)),n_dep)), n_subj)
  for(s in 1:n_subj){
    for(q in 1:n_dep){
      est_emiss[[s]][[q]][] <- matrix(round(apply(object$PD_subj[[s]][burn_in:J, (1+(q-1)*m) : (m+(q-1)*m)], 2, median), 4),
                                      byrow = TRUE, nrow = m, ncol = 1)
      est_emiss[[s]][[q]][] <- matrix(round(c(apply(object$PD_subj[[s]][burn_in:J, ((q-1) * m + 1) : ((q-1) * m + m)], 2, median),
                                              apply(object$PD_subj[[s]][burn_in:J, (n_dep * m + (q-1) * m + 1) : (n_dep * m + (q-1) * m + m)], 2, median)),
                                            3),
                                      ncol = 2,
                                      nrow = m)
    }
  }
  est_gamma <- obtain_gamma(object, level = "subject")
  for(s in 1:n_subj){
    emiss <- est_emiss[[s]]
    gamma    <- est_gamma[[s]]
    probs    <- cont_mult_fw_r_to_cpp(x = as.matrix(s_data[s_data[,1] == id[s],][,-1], ncol = n_dep),
                                      m = m, emiss = emiss, n_dep = n_dep, gamma = gamma)[[1]]
    state_seq[1:n_vary[s], s] <- apply(probs, 2, which.max)
  }
  colnames(state_seq) <- paste("Subj_", id, sep = "")
  return(state_seq)
}
