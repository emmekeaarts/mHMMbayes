#' Obtain hidden state sequence for each subject using the Viterbi
#' algorithm
#'
#' \code{vit_mHMM_vary} obtains the most likely state sequence (for each subject)
#' from an object of class \code{mHMM_vary} (generated by the
#' function \code{mHMM_vary()} for sequences obtained from multiple subjects or animals,
#' respectively), using (an extended version of) the Viterbi algorithm. This is
#' also known as global decoding.
#'
#' Note that local decoding is also possible, by inferring the most frequent
#' state at each point in time for each subject from the sampled state path at
#' each iteration of the MCMC algorithm. This information is contained in the
#' output object \code{return_path} of the function \code{mHMM_vary()}.
#'
#' @param object An object of class \code{mHMM_vary}, generated by the
#'   function \code{\link{mHMM_vary}}, respectively.
#' @inheritParams mHMM
#' @param burn_in The number of iterations to be discarded from the MCMC
#'   algorithm when inferring the transition probability matrix gamma and the
#'   emission distribution of (each of) the dependent variable(s) for each
#'   subject from \code{s_data}. If omitted, defaults to \code{NULL} and
#'   \code{burn_in} specified at the function \code{mHMM} will be used.
#'
#' @return The function \code{vit_mHMM_vary} returns a matrix containing the most
#'   likely state at each point in time. Each column represents a subject, and
#'   each row represents a point in time. If sequence lengths differ over
#'   subjects, states for none existing time points for subjects are filled with
#'   \code{NA}.
#'
#' @export


vit_mHMM_vary <- function(object, s_data, burn_in = NULL){

  if (!("mHMM_vary" %in% class(object))){
    stop("The input object used should be from the class mHMM_vary, obtained by using the function mHMM_vary.")
  }
  # if (!is.mHMM_cont(object)){ ## THIS VERSION PRODUCES AN ERROR
  #   stop("The input object used should be from the class mHMM_cont, obtained by using the function mHMM_cont.")
  # }
  id         <- unique(s_data[,1])
  n_subj     <- length(id)
  if(length(object$PD_subj) != n_subj){
    stop("s_data used should be identical to the data used for creating the object in mHMM_cont.
         The number of subjects in the datasets are not the same.")
  }
  n_vary     <- table(s_data[,1])
  max_n      <- max(n_vary)
  state_seq  <- matrix(,ncol = n_subj, nrow = max_n)

  input      <- object$input
  n_dep      <- input$n_dep
  data_distr <- input$data_distr
  n_cat      <- sum(data_distr %in% 'categorical')
  n_cont     <- sum(data_distr %in% 'continuous')
  which_cat  <- which(data_distr %in% 'categorical')
  which_cont <- which(data_distr %in% 'continuous')
  if(n_cat > 0){
    q_emiss <- input$q_emiss
  }
  m          <- input$m
  q_emiss    <- input$q_emiss
  if(is.null(burn_in)){
    burn_in  <- input$burn_in
  }
  J          <- input$J
  if (burn_in >= (J-1)){
    stop(paste("The specified burn in period should be at least 2 points smaller
               compared to the number of iterations J, J =", J))
  }
  est_emiss  <- rep(vector("list", n_dep), n_subj)
  for(s in 1:n_subj){
    if(n_cat > 0){
      start <- c(0, q_emiss * m)
      for(q in 1:n_cat){
        ind <- which_cat[q]
        est_emiss[[s]][[ind]] <- matrix(round(apply(object$PD_subj[[s]]$cat_emiss[burn_in:J, (sum(start[1:q]) + 1) : sum(start[1:(q+1)])], 2, median), 3),
                                            byrow = TRUE, ncol = q_emiss[ind], nrow = m)
      }
    }
    if(n_cont > 0){
      for(q in 1:n_cont){
        ind <- which_cont[q]
        est_emiss[[s]][[ind]] <- matrix(round(c(apply(object$PD_subj[[s]]$cont_emiss[((burn_in + 1): J),((q-1) * m + 1) : ((q-1) * m + m)], 2, median),
                                                    apply(object$PD_subj[[s]]$cont_emiss[((burn_in + 1): J),(n_cont * m + (q-1) * m + 1) : (n_cont * m + (q-1) * m + m)], 2, median)),3), ncol = 2, nrow = m)
      }
    }
  }
  est_gamma <- obtain_gamma(object, level = "subject")
  for(s in 1:n_subj){
    emiss <- est_emiss[[s]]
    gamma    <- est_gamma[[s]]
    probs    <- vary_mult_fw_r_to_cpp(x = as.matrix(s_data[s_data[,1] == id[s],][,-1], ncol = n_dep),
                          m = m, emiss = emiss, gamma = gamma, n_dep = n_dep, delta=NULL, data_distr = data_distr)[[1]]
    state_seq[1:n_vary[s], s] <- apply(probs, 2, which.max)
  }
  colnames(state_seq) <- paste("Subj_", id, sep = "")
  return(state_seq)
}
